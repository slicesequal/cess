use anyhow::{anyhow, Context, Result};
use clap::Parser;
use std::{
	path::{Path, PathBuf},
	process::{ExitStatus, Stdio},
};
use tokio::{
	fs,
	io::{AsyncBufReadExt, BufReader, Lines},
	process::{Child, ChildStdout, Command},
	select,
	time::{timeout, Duration},
};

macro_rules! log {
    ($($arg:tt)*) => {
		println!("[HandoverðŸ¤] {}", format!($($arg)*))
    }
}

#[derive(Parser, Debug)]
#[command(about = "Handover tool for ceseal", version, author)]
pub struct Args {
	#[arg(long, help = "The path of the ceseal home directory", default_value = "/opt/ceseal")]
	pub ceseal_home: PathBuf,

	#[arg(long, help = "old ceseal start on this port", default_value = "1888")]
	pub previous_port: u16,
}

const FRAG_DATA_PROTECTED: &str = "data/protected_files";
const FRAG_DATA_STORAGE: &str = "data/storage_files";

pub struct PathLayout {
	current_release_dir: PathBuf,
	config_file: PathBuf,
	backups_dir: PathBuf,
	datas_dir: PathBuf,
}

impl PathLayout {
	pub fn new(home: &Path) -> Self {
		let current_release_dir = home.join("releases").join("current");
		let config_file = current_release_dir.join(FRAG_DATA_STORAGE).join("config.toml");
		let backups_dir = home.join("backups");
		let datas_dir = home.join("data");

		Self { current_release_dir, config_file, backups_dir, datas_dir }
	}

	pub fn current_id_key_path(&self) -> PathBuf {
		self.current_release_dir.join(FRAG_DATA_PROTECTED).join("id_key.seal")
	}

	pub async fn current_version_number(&self) -> Result<u64> {
		let real_path = fs::read_link(&self.current_release_dir)
			.await
			.context(format!("Failed to read symlink: {:?}", &self.current_release_dir))?;
		real_path
			.file_name()
			.ok_or(anyhow!("Failed to get filename of path: {:?}", &real_path))?
			.to_string_lossy()
			.parse::<u64>()
			.context(format!("Failed to parse current ceseal version from path: {:?}", &real_path))
	}

	async fn ensure_current_version_data_dir(&self, current_version: u64) -> Result<()> {
		let data_dir = self.datas_dir.join(current_version.to_string());
		if !data_dir.exists() {
			fs::create_dir_all(&data_dir).await?;
		}
		// Create the protected_files subdirectory if it does not exist
		let protected_files_dir = data_dir.join("protected_files");
		if !protected_files_dir.exists() {
			fs::create_dir_all(&protected_files_dir).await?;
			log!("Created dir: {}", protected_files_dir.display());
		}

		let storage_files_dir = data_dir.join("storage_files");
		if !storage_files_dir.exists() {
			fs::create_dir_all(&storage_files_dir).await?;
			log!("Created dir: {}", storage_files_dir.display());
		}
		Ok(())
	}

	pub async fn previous_version_number(&self, current_version: u64) -> Result<u64> {
		if !self.backups_dir.exists() {
			fs::create_dir_all(&self.backups_dir).await?;
			return Ok(0);
		}

		let mut entries = fs::read_dir(&self.backups_dir).await?;
		let mut versions = vec![];
		while let Some(entry) = entries.next_entry().await? {
			let path = entry.path();
			if path.is_dir() {
				if let Some(file_name) = path.file_name() {
					versions.push(
						file_name
							.to_str()
							.ok_or(anyhow!("error file appears in the path {:?}", &self.backups_dir))?
							.parse::<u64>()?,
					)
				}
			}
		}
		versions.sort_by(|a, b| b.cmp(a));

		let mut previous_version = 0;
		for version in versions {
			if previous_version == 0 || previous_version < version {
				if version >= current_version {
					continue;
				}
				previous_version = version;
				break;
			}
		}
		Ok(previous_version)
	}

	async fn backup_current_release_if_need(&self, current_version: u64) -> Result<()> {
		let current_version_backup_dir = self.backups_dir.join(current_version.to_string());
		if !current_version_backup_dir.exists() {
			log!("Backing up current version to: {:?}", &current_version_backup_dir);
			copy_directory(&self.current_release_dir, &current_version_backup_dir).await?;
		}
		Ok(())
	}

	async fn fix_previous_data_dir_if_need(&self, previous_version: u64) -> Result<bool> {
		if previous_version == 0 {
			return Ok(false);
		}
		//Everytime publish next version of ceseal will be detect overhere
		//Let's backup the previous id_key.seal file into 'backups ceseal's data first
		let previous_version = previous_version.to_string();
		let previous_id_key = self
			.backups_dir
			.join(&previous_version)
			.join(FRAG_DATA_PROTECTED)
			.join("id_key.seal");
		if !previous_id_key.exists() {
			log!("No 'id_key.seal' found in previous version {previous_version}, fix it from {:?} now", self.datas_dir);
			//Since the data generated by ceseal was not saved to the '/opt/ceseal/backups' path after exiting
			// when it was started for the first time, it needs to be synchronized here to avoid data loss from data to
			// backup.
			copy_directory(
				&self.datas_dir.join(&previous_version),
				&self.backups_dir.join(&previous_version).join("data"),
			)
			.await?;
		}
		Ok(true)
	}

	async fn run_previous_ceseal_until_on_serving(&self, previous_version: u64, previous_port: u16) -> Result<Child> {
		log!("Starting previous version({}) ceseal", previous_version);
		let previous_ceseal_home_dir = self.backups_dir.join(previous_version.to_string());

		//Reuse current config.toml file for previous ceseal startup
		let pre_config_file = previous_ceseal_home_dir.join(FRAG_DATA_STORAGE).join("config.toml");
		log!("Copy current config file to previous ceseal: {:?}", &pre_config_file);
		fs::copy(&self.config_file, &pre_config_file).await?;

		let extra_args =
			format!("-c=/data/storage_files/config.toml --listening-port={} --only-handover-server", previous_port);
		let mut cmd = Command::new(previous_ceseal_home_dir.join("start.sh"));
		let mut process = cmd
			.stdin(Stdio::piped())
			.stdout(Stdio::piped())
			// .stderr(Stdio::piped())
			.env("SKIP_AESMD", "1")
			.env("EXTRA_OPTS", extra_args)
			.spawn()?;

		//wait for preivious ceseal went well
		let ret =
			wait_for_a_message_or_exit(&mut process, "The ceseal server will listening on", Some(60), "server").await?;
		if ret != WaitResult::MeetMessage {
			return Err(anyhow!("Failed to start previous ceseal: {:?}", ret));
		}
		log!("Previous ceseal on serving!");

		// Remove config.toml file after previous started, since config.toml is mounted from host environment
		let ret = fs::remove_file(&pre_config_file).await;
		log!("Remove previous ceseal config file: {:?}, return: {:?}", &pre_config_file, ret);
		Ok(process)
	}

	async fn run_current_ceseal_until_on_serving(&self, previous_port: u16) -> Result<Child> {
		let mut process = Command::new("/opt/ceseal/releases/current/gramine-sgx")
			.args(&[
				"ceseal",
				&format!("--request-handover-from=http://localhost:{}", previous_port),
				"-c=/data/storage_files/config.toml",
			])
			.current_dir(&self.current_release_dir)
			.stdout(Stdio::piped())
			.stderr(Stdio::piped())
			.spawn()?;

		let ret = wait_for_a_message_or_exit(&mut process, "Handover done", Some(60), "client").await?;
		if !(ret == WaitResult::MeetMessage || ret == WaitResult::NormalExit) {
			return Err(anyhow!("Failed to start current ceseal: {:?}", ret));
		}
		log!("Current ceseal report handover is complete.");
		Ok(process)
	}

	async fn copy_storage_dir_to_current(&self, previous_version: u64) -> Result<()> {
		let current_storage_dir = self.current_release_dir.join(FRAG_DATA_STORAGE);
		let previous_storage_dir = self.backups_dir.join(previous_version.to_string()).join(FRAG_DATA_STORAGE);
		if previous_storage_dir.exists() {
			copy_directory(&previous_storage_dir, &current_storage_dir).await?;
			log!("Copy storage files from {} to {}", previous_storage_dir.display(), current_storage_dir.display());
		} else {
			log!("No previous storage files found, skip copy");
		}
		Ok(())
	}
}

#[tokio::main]
async fn main() -> Result<()> {
	let args = Args::parse();
	let path_layout = PathLayout::new(&args.ceseal_home);

	let current_version = path_layout.current_version_number().await?;
	log!("Current version: {}", current_version);
	path_layout.ensure_current_version_data_dir(current_version).await?;

	// Anyway, back up the current version if need
	path_layout
		.backup_current_release_if_need(current_version)
		.await
		.context("Failed to backup current version")?;

	// Get the path to the current Ceseal version and check whether it has been initialized.
	let current_id_key_path = path_layout.current_id_key_path();
	if current_id_key_path.exists() {
		log!("The `id_key.seal` exists, no need to handover");
		return Ok(());
	}

	let previous_version = path_layout.previous_version_number(current_version).await?;
	if previous_version == 0 {
		log!("No previous version, no need to handover!");
		return Ok(());
	}

	log!("Previous version: {previous_version}");
	path_layout
		.fix_previous_data_dir_if_need(previous_version)
		.await
		.context("Failed to fix previous data dir")?;

	// If the current version is the same as the previous version, there is no need to hand over and exit directly.
	if previous_version == current_version {
		log!("Same version, no need to handover");
		return Ok(());
	}

	// Run old ceseal
	let _ = path_layout
		.run_previous_ceseal_until_on_serving(previous_version, args.previous_port)
		.await?;
	// Run new ceseal
	let _ = path_layout
		.run_current_ceseal_until_on_serving(args.previous_port)
		.await?;

	path_layout.copy_storage_dir_to_current(previous_version).await?;

	log!("Handover success!");
	Ok(())
}

#[derive(Debug, PartialEq)]
pub enum WaitResult {
	MeetMessage,
	StdoutEof,
	NormalExit,
	AbnormalExit(ExitStatus),
	Timeout,
}

async fn wait_for_a_message_or_exit(
	child: &mut Child,
	message: &str,
	timeout_secs: Option<u64>,
	message_tag: &str,
) -> Result<WaitResult> {
	let stdout = child.stdout.take().expect("Child must have stdout");
	let mut lines = BufReader::new(stdout).lines();
	let stdout_keeper = async |mut lines: Lines<BufReader<ChildStdout>>| loop {
		match lines.next_line().await {
			Ok(ss) => {
				if ss.is_none() {
					break;
				}
			},
			Err(e) => {
				log!("Error reading stdout: {}", e);
				break;
			},
		}
	};
	let wait_fut = async {
		loop {
			select! {
				line = lines.next_line() => {
					match line? {
						Some(l) => {
							log!("[{message_tag}] {}", l.trim_end());
							if l.contains(message) {
								tokio::spawn(stdout_keeper(lines));
								return Ok(WaitResult::MeetMessage);
							}
						}
						None => return Ok(WaitResult::StdoutEof),
					}
				}
				status = child.wait() => {
					let status = status?;
					if status.success() {
						return Ok(WaitResult::NormalExit);
					} else {
						log!("Process({:?}) exited with status: {}", child.id(), status);
						return Ok(WaitResult::AbnormalExit(status));
					}
				}
			}
		}
	};

	match timeout_secs {
		Some(secs) => match timeout(Duration::from_secs(secs), wait_fut).await {
			Ok(res) => res,
			Err(_) => Ok(WaitResult::Timeout),
		},
		None => wait_fut.await,
	}
}

async fn copy_directory(source: &Path, destination: &Path) -> Result<()> {
	use walkdir::WalkDir;
	for entry in WalkDir::new(source).into_iter().filter_map(Result::ok) {
		let path = entry.path();
		let relative_path = path.strip_prefix(source)?;
		let dest_path = destination.join(relative_path);
		if path.is_dir() {
			fs::create_dir_all(&dest_path).await?;
		} else if path.is_file() {
			fs::copy(path, &dest_path).await?;
		}
	}
	Ok(())
}
