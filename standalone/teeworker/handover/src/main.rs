//mod arg;

use anyhow::{anyhow, Context, Result};
use clap::Parser;
use std::{
	path::{Path, PathBuf},
	process::Stdio,
};
use tokio::{
	fs,
	io::{AsyncBufReadExt, BufReader, BufWriter},
	process::{Child, ChildStdout, Command},
};

macro_rules! log {
    ($($arg:tt)*) => {
		println!("[HandoverðŸ¤] {}", format!($($arg)*))
    }
}

#[derive(Parser, Debug)]
#[command(about = "Handover tool for ceseal", version, author)]
pub struct Args {
	#[arg(long, help = "The path of the ceseal home directory", default_value = "/opt/ceseal")]
	pub ceseal_home: PathBuf,

	#[arg(long, help = "old ceseal start on this port", default_value = "1888")]
	pub previous_port: u16,

	#[arg(long, help = "remote attestation type")]
	pub ra_type: String,
}

const FRAG_DATA_PROTECTED: &str = "data/protected_files";
const FRAG_DATA_STORAGE: &str = "data/storage_files";

pub struct PathLayout {
	current_release_dir: PathBuf,
	config_file: PathBuf,
	backups_dir: PathBuf,
	datas_dir: PathBuf,
	previous_log_path: PathBuf,
	current_log_path: PathBuf,
}

impl PathLayout {
	pub fn new(home: &Path) -> Self {
		let current_release_dir = home.join("releases").join("current");
		let config_file = current_release_dir.join(FRAG_DATA_STORAGE).join("config.toml");
		let backups_dir = home.join("backups");
		let datas_dir = home.join("data");
		let previous_log_path = home.join("pre_ceseal.log");
		let current_log_path = home.join("current_ceseal.log");

		Self { current_release_dir, config_file, backups_dir, datas_dir, previous_log_path, current_log_path }
	}

	pub fn current_id_key_path(&self) -> PathBuf {
		self.current_release_dir.join(FRAG_DATA_PROTECTED).join("id_key.seal")
	}

	pub async fn current_version_number(&self) -> Result<u64> {
		let real_path = fs::read_link(&self.current_release_dir)
			.await
			.context(format!("Failed to read symlink: {:?}", &self.current_release_dir))?;
		real_path
			.file_name()
			.ok_or(anyhow!("Failed to get filename of path: {:?}", &real_path))?
			.to_string_lossy()
			.parse::<u64>()
			.context(format!("Failed to parse current ceseal version from path: {:?}", &real_path))
	}

	async fn ensure_current_version_data_dir(&self, current_version: u64) -> Result<()> {
		let data_dir = self.datas_dir.join(current_version.to_string());
		if !data_dir.exists() {
			fs::create_dir_all(&data_dir).await?;
		}
		// Create the protected_files subdirectory if it does not exist
		let protected_files_dir = data_dir.join("protected_files");
		if !protected_files_dir.exists() {
			fs::create_dir_all(&protected_files_dir).await?;
			log!("Created dir: {}", protected_files_dir.display());
		}

		let storage_files_dir = data_dir.join("storage_files");
		if !storage_files_dir.exists() {
			fs::create_dir_all(&storage_files_dir).await?;
			log!("Created dir: {}", storage_files_dir.display());
		}
		Ok(())
	}

	pub async fn previous_version_number(&self, current_version: u64) -> Result<u64> {
		if !self.backups_dir.exists() {
			fs::create_dir_all(&self.backups_dir).await?;
			return Ok(0);
		}

		let mut entries = fs::read_dir(&self.backups_dir).await?;
		let mut versions = vec![];
		while let Some(entry) = entries.next_entry().await? {
			let path = entry.path();
			if path.is_dir() {
				if let Some(file_name) = path.file_name() {
					versions.push(
						file_name
							.to_str()
							.ok_or(anyhow!("error file appears in the path {:?}", &self.backups_dir))?
							.parse::<u64>()?,
					)
				}
			}
		}
		versions.sort_by(|a, b| b.cmp(a));

		let mut previous_version = 0;
		for version in versions {
			if previous_version == 0 || previous_version < version {
				if version >= current_version {
					continue;
				}
				previous_version = version;
				break;
			}
		}
		Ok(previous_version)
	}

	async fn backup_current_release_if_need(&self, current_version: u64) -> Result<()> {
		let current_version_backup_dir = self.backups_dir.join(current_version.to_string());
		if !current_version_backup_dir.exists() {
			log!("Backing up current version to: {:?}", &current_version_backup_dir);
			copy_directory(&self.current_release_dir, &current_version_backup_dir).await?;
		}
		Ok(())
	}

	async fn fix_previous_data_dir_if_need(&self, previous_version: u64) -> Result<bool> {
		if previous_version == 0 {
			return Ok(false);
		}
		//Everytime publish next version of ceseal will be detect overhere
		//Let's backup the previous id_key.seal file into 'backups ceseal's data first
		let previous_version = previous_version.to_string();
		let previous_id_key = self
			.backups_dir
			.join(&previous_version)
			.join(FRAG_DATA_PROTECTED)
			.join("id_key.seal");
		if !previous_id_key.exists() {
			log!("No 'id_key.seal' found in previous version {previous_version}, fix it from {:?} now", self.datas_dir);
			//Since the data generated by ceseal was not saved to the '/opt/ceseal/backups' path after exiting
			// when it was started for the first time, it needs to be synchronized here to avoid data loss from data to
			// backup.
			copy_directory(
				&self.datas_dir.join(&previous_version),
				&self.backups_dir.join(&previous_version).join("data"),
			)
			.await?;
		}
		Ok(true)
	}

	async fn remove_log_files(&self) -> Result<()> {
		if self.previous_log_path.exists() {
			let _ = fs::remove_file(&self.previous_log_path).await;
		}
		if self.current_log_path.exists() {
			let _ = fs::remove_file(&self.current_log_path).await;
		}
		Ok(())
	}

	async fn run_previous_ceseal_until_on_serving(&self, previous_version: u64, previous_port: u16) -> Result<Child> {
		let previous_ceseal_home_dir = self.backups_dir.join(previous_version.to_string());

		//Reuse current config.toml file for previous ceseal startup
		let pre_config_file = previous_ceseal_home_dir.join(FRAG_DATA_STORAGE).join("config.toml");
		if !pre_config_file.exists() {
			log!("Copy current config file to previous ceseal: {:?}", &pre_config_file);
			fs::copy(&self.config_file, &pre_config_file).await?;
		}

		let extra_args =
			format!("-c=/data/storage_files/config.toml --listening-port={} --only-handover-server", previous_port);
		let mut cmd = Command::new(previous_ceseal_home_dir.join("start.sh"));
		let mut process = cmd
			.stdin(Stdio::piped())
			.stdout(Stdio::piped())
			// .stderr(Stdio::piped())
			.env("SKIP_AESMD", "1")
			.env("EXTRA_OPTS", extra_args)
			.spawn()?;

		// Remove config.toml file after previous started, since config.toml is mounted from host environment
		if pre_config_file.exists() {
			let _ = fs::remove_file(&pre_config_file).await;
		}

		redirect_stdout(process.stdout.take().ok_or(anyhow!("process missing stdout"))?, &self.previous_log_path)
			.await?;
		//wait for preivious ceseal went well
		wait_for_a_message(&self.previous_log_path, "server", "The ceseal server will listening on").await?;
		log!("Previous ceseal on serving!");
		Ok(process)
	}

	async fn run_current_ceseal_until_on_serving(&self, previous_port: u16, ra_type: &str) -> Result<Child> {
		let mut process = Command::new("/opt/ceseal/releases/current/gramine-sgx")
			.args(&[
				"ceseal",
				&format!("--request-handover-from=http://localhost:{}", previous_port),
				&format!("--ra-type={}", ra_type),
				"-c=/data/storage_files/config.toml",
			])
			.current_dir(&self.current_release_dir)
			.stdout(Stdio::piped())
			.stderr(Stdio::piped())
			.spawn()?;

		redirect_stdout(process.stdout.take().ok_or(anyhow!("process missing stdout"))?, &self.current_log_path)
			.await?;
		wait_for_a_message(&self.current_log_path, "client", "Handover done").await?;
		log!("Current ceseal on serving!");
		Ok(process)
	}

	async fn copy_storage_dir_to_current(&self, previous_version: u64) -> Result<()> {
		let current_storage_dir = self.current_release_dir.join(FRAG_DATA_STORAGE);
		fs::remove_dir_all(&current_storage_dir).await?;
		let previous_storage_dir = self.backups_dir.join(previous_version.to_string()).join(FRAG_DATA_STORAGE);
		if previous_storage_dir.exists() {
			copy_directory(&previous_storage_dir, &current_storage_dir).await?;
			log!("Copy storage files from {} to {}", previous_storage_dir.display(), current_storage_dir.display());
		} else {
			log!("No previous storage files found, skip copy");
		}
		Ok(())
	}
}

#[tokio::main]
async fn main() -> Result<()> {
	let args = Args::parse();
	let path_layout = PathLayout::new(&args.ceseal_home);
	// Get the path to the current Ceseal version and check whether it has been initialized.
	let current_id_key_path = path_layout.current_id_key_path();
	if current_id_key_path.exists() {
		log!("The `id_key.seal` exists, no need to handover");
		return Ok(());
	}

	let current_version = path_layout.current_version_number().await?;
	log!("Current version: {}", current_version);
	path_layout.ensure_current_version_data_dir(current_version).await?;

	let previous_version = path_layout.previous_version_number(current_version).await?;
	if previous_version == 0 {
		log!("No previous version, no need to handover!");
		return Ok(());
	}

	log!("Previous {previous_version}");
	path_layout
		.fix_previous_data_dir_if_need(previous_version)
		.await
		.context("Failed to fix previous data dir")?;

	// Anyway, back up the current version
	path_layout
		.backup_current_release_if_need(current_version)
		.await
		.context("Failed to backup current version")?;

	// If the current version is the same as the previous version, there is no need to hand over and exit directly.
	if previous_version == current_version {
		log!("Same version, no need to handover");
		return Ok(());
	}

	path_layout.remove_log_files().await?;

	// Run old ceseal
	let old_ceseal_process = path_layout
		.run_previous_ceseal_until_on_serving(previous_version, args.previous_port)
		.await?;
	// Run new ceseal
	let _ = path_layout
		.run_current_ceseal_until_on_serving(args.previous_port, &args.ra_type)
		.await?;
	log!("Handover success!");

	kill_previous_ceseal(old_ceseal_process, previous_version).await?;

	path_layout.copy_storage_dir_to_current(previous_version).await?;
	Ok(())
}

async fn redirect_stdout(stdout: ChildStdout, log_path: &Path) -> Result<()> {
	//redirect process log into new created log file
	let log_file = fs::OpenOptions::new()
		.read(true)
		.write(true)
		.create(true)
		.open(log_path)
		.await?;
	let mut log_writer = BufWriter::new(log_file);
	let mut reader = BufReader::new(stdout);

	tokio::spawn(async move {
		tokio::io::copy(&mut reader, &mut log_writer)
			.await
			.expect("Error piping stdout to log file");
	});
	Ok(())
}

async fn wait_for_a_message(log_path: &Path, tag: &str, message: &str) -> Result<()> {
	let sleep_for_ceseal_running = tokio::time::Duration::from_secs(5);
	let mut sleep_times = 60; //TODO! To extract the hard code into configured parameters
	let mut reader = BufReader::new(
		fs::File::open(log_path)
			.await
			.context(format!("Failed to open log file: {:?}", log_path))?,
	);
	let mut line = String::new();
	loop {
		match reader.read_line(&mut line).await {
			Ok(bytes_read) if bytes_read > 0 => {
				log!("[{tag}] {}", line.trim_end());
				if line.contains(message) {
					return Ok(());
				}
				line.clear();
			},
			Ok(_) => {
				if sleep_times > 0 {
					tokio::time::sleep(sleep_for_ceseal_running).await;
					sleep_times -= 1;
					continue;
				}
				return Err(anyhow!("Ceseal did not start successfully within the expected time"));
			},
			Err(err) => return Err(anyhow!("Error reading log file: {:?}", err)),
		}
	}
}

async fn copy_directory(source: &Path, destination: &Path) -> Result<()> {
	use walkdir::WalkDir;
	for entry in WalkDir::new(source).into_iter().filter_map(Result::ok) {
		let path = entry.path();
		let relative_path = path.strip_prefix(source)?;
		let dest_path = destination.join(relative_path);
		if path.is_dir() {
			fs::create_dir_all(&dest_path).await?;
		} else if path.is_file() {
			fs::copy(path, &dest_path).await?;
		}
	}
	Ok(())
}

async fn kill_previous_ceseal(mut process: Child, version: u64) -> Result<()> {
	log!("Start to kill the previous ceseal process: {:?}, version: {}", process.id(), version);
	process.kill().await?;

	let script =
		format!("ps -eaf | grep \"backups/{}/cruntime/sgx/loader\" | grep -v \"grep\" | awk '{{print $2}}'", version);
	let mut bash = Command::new("bash");
	let cmd = bash.arg("-c").arg(script).stdout(Stdio::piped()).stderr(Stdio::piped());
	let process = cmd.spawn()?;
	let output = process.wait_with_output().await?;
	if output.status.success() {
		let pid_str = String::from_utf8_lossy(&output.stdout);
		if let Ok(pid) = pid_str.trim().parse::<i32>() {
			log!("Kill the gramine loader (pid: {pid}) of the previous ceseal version {version}");
			Command::new("kill").arg("-9").arg(pid.to_string()).status().await?;
		}
	} else {
		log!("Run cmd: {:?} rasie error: {}", cmd, String::from_utf8_lossy(&output.stderr));
	}
	Ok(())
}
