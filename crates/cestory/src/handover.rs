use crate::{
    as_status, attestation::create_attestation_report_on, unix_now, BlockNumber, CesealClient, CesealMasterKey,
    ChainQueryHelper, Config, IdentityKey, RpcResult, RpcStatusSource,
};
use anyhow::{anyhow, Result};
use ces_crypto::{
    ecdh::EcdhKey,
    key_share,
    sr25519::{Persistence, KDF},
    SecretKey,
};
use ces_types::{
    attestation::{validate as validate_attestation_report, SgxFields},
    AttestationReport, ChallengeHandlerInfo, EncryptedKeyStaffs, HandoverChallenge,
};
use cestory_api::handover::{
    self as pb,
    handover_server_api_server::{HandoverServerApi, HandoverServerApiServer},
};
use parity_scale_codec::{Decode, Encode};
use ring::rand::SecureRandom;
use sp_core::sr25519;
use std::{
    path::PathBuf,
    str::FromStr,
    sync::{Arc, RwLock},
};
use tonic::{Request, Response, Status};

fn generate_random_info() -> [u8; 32] {
    let mut nonce_vec = [0u8; 32];
    let rand = ring::rand::SystemRandom::new();
    rand.fill(&mut nonce_vec).unwrap();
    nonce_vec
}

pub async fn new_handover_server(
    ceseal_client: CesealClient,
    cqh: ChainQueryHelper,
) -> Result<HandoverServerApiServer<HandoverServerImpl>> {
    let dev_mode = ceseal_client.identity_key().await?.dev_mode;
    let svc = HandoverServerImpl { dev_mode, ceseal_client, cqh, handover_challenge: RwLock::new(None) };
    Ok(HandoverServerApiServer::new(svc))
}

pub struct HandoverServerImpl {
    dev_mode: bool,
    ceseal_client: CesealClient,
    cqh: ChainQueryHelper,
    handover_challenge: RwLock<Option<HandoverChallenge<BlockNumber>>>,
}

impl HandoverServerImpl {
    fn get_worker_key_challenge(&self, block_number: BlockNumber, now: u64) -> HandoverChallenge<BlockNumber> {
        let sgx_target_info = if self.dev_mode {
            vec![]
        } else {
            let my_target_info = sgx_api_lite::target_info().unwrap();
            sgx_api_lite::encode(&my_target_info).to_vec()
        };
        let challenge = HandoverChallenge {
            sgx_target_info,
            block_number,
            now,
            dev_mode: self.dev_mode,
            nonce: generate_random_info(),
        };
        self.handover_challenge
            .write()
            .expect("got handover_challenge write lock")
            .replace(challenge.clone());
        challenge
    }

    fn verify_worker_key_challenge(&self, challenge: &HandoverChallenge<BlockNumber>) -> bool {
        return self
            .handover_challenge
            .write()
            .expect("got handover_challenge write lock")
            .take()
            .as_ref()
            == Some(challenge);
    }
}

#[tonic::async_trait]
impl HandoverServerApi for HandoverServerImpl {
    /// Key Handover Server: Get challenge for worker key handover from another ceSeal
    async fn create_challenge(&self, _: Request<()>) -> RpcResult<pb::HandoverChallenge> {
        let (block, ts) = self.cqh.current_block().await.map_err(as_status)?;
        let challenge = self.get_worker_key_challenge(block, ts);
        Ok(Response::new(pb::HandoverChallenge::new(challenge)))
    }

    /// Key Handover Server: Get worker key with RA report on challenge from another Ceseal
    async fn start(&self, request: Request<pb::HandoverChallengeResponse>) -> RpcResult<pb::HandoverKeyStaffs> {
        let request = request.into_inner();
        let id_key = self.ceseal_client.identity_key().await.map_err(as_status)?;
        let master_key = self.ceseal_client.master_key().await.map_err(as_status)?;
        let in_sgx = self.ceseal_client.is_sgx_env().await.map_err(as_status)?;
        let dev_mode = id_key.dev_mode;
        let (block_number, now_ms) = self.cqh.current_block().await.map_err(as_status)?;

        // 1. verify client RA report to ensure it's in sgx
        // this also ensure the message integrity
        let challenge_handler = request.decode_challenge_handler().map_err(as_status)?;
        let block_sec = now_ms / 1000;
        let attestation = if !dev_mode && in_sgx {
            let payload_hash = sp_core::hashing::blake2_256(&challenge_handler.encode());
            let raw_attestation = request
                .attestation
                .ok_or_else(|| anyhow!("Client attestation not found").as_status())?;
            let attn_to_validate =
                Option::<AttestationReport>::decode(&mut &raw_attestation.encoded_report[..]).map_err(as_status)?;
            // The time from attestation report is generated by IAS, thus trusted. By default, it's valid for **10h**.
            // By ensuring our system timestamp is within the valid period, we know that this ceseal is not hold back by
            // malicious workers.
            validate_attestation_report(attn_to_validate.clone(), &payload_hash, block_sec, false, vec![], false)
                .map_err(as_status)?;
            attn_to_validate
        } else {
            info!("Skip client RA report check in dev mode");
            None
        };
        // 2. verify challenge validity to prevent replay attack
        let challenge = challenge_handler.challenge;
        if !self.verify_worker_key_challenge(&challenge) {
            return Err(Status::invalid_argument("Invalid challenge"));
        }
        // 3. verify sgx local attestation report to ensure the handover ceseals are on the same machine
        if !dev_mode && in_sgx {
            let recv_local_report =
                unsafe { sgx_api_lite::decode(&challenge_handler.sgx_local_report).map_err(as_status)? };
            sgx_api_lite::verify(recv_local_report).map_err(as_status)?;
        } else {
            info!("Skip client LA report check in dev mode");
        }
        // 4. verify challenge block height and report timestamp
        // only challenge within 150 blocks (30 minutes) is accepted
        let challenge_height = challenge.block_number;
        if !(challenge_height <= block_number && block_number - challenge_height <= 150) {
            return Err(Status::invalid_argument("Outdated challenge"));
        }
        // 5. verify ceseal launch date, never handover to old ceseal
        if !dev_mode && in_sgx {
            let my_la_report = {
                // target_info and reportdata not important, we just need the report metadata
                let target_info = sgx_api_lite::target_info().expect("should not fail in SGX; qed.");
                sgx_api_lite::report(&target_info, &[0; 64])
                    //.context("Cannot read server ceseal info")
                    .map_err(as_status)?
            };
            let my_ceseal_hash = {
                let sgx_fields = SgxFields {
                    mr_enclave: my_la_report.body.mr_enclave.m,
                    mr_signer: my_la_report.body.mr_signer.m,
                    isv_prod_id: my_la_report.body.isv_prod_id.to_ne_bytes(),
                    isv_svn: my_la_report.body.isv_svn.to_ne_bytes(),
                    report_data: [0; 64],
                    confidence_level: 0,
                };
                sgx_fields.measurement_hash()
            };
            let attestation = attestation.ok_or_else(|| anyhow!("Client attestation not found").as_status())?;
            let req_ceseal_hash = match attestation {
                AttestationReport::SgxIas { ra_report, signature: _, raw_signing_cert: _ } => {
                    let (sgx_fields, _) = SgxFields::from_ias_report(&ra_report)
                        .map_err(|_| anyhow!("Invalid client RA report").as_status())?;
                    sgx_fields.measurement_hash()
                },
                AttestationReport::SgxDcap { quote, collateral: _ } => {
                    let (sgx_fields, _) = SgxFields::from_dcap_quote_report(&quote)
                        .map_err(|_| anyhow!("Invalid client RA report").as_status())?;
                    sgx_fields.measurement_hash()
                },
            };
            if my_ceseal_hash != req_ceseal_hash {
                let my_ceseal_timestamp = self
                    .cqh
                    .get_ceseal_bin_added_at(&my_ceseal_hash)
                    .await
                    .map_err(as_status)?
                    .ok_or_else(|| Status::internal("Server ceseal not allowed on chain"))?;
                let req_ceseal_timestamp = self
                    .cqh
                    .get_ceseal_bin_added_at(&req_ceseal_hash)
                    .await
                    .map_err(as_status)?
                    .ok_or_else(|| Status::internal("Client ceseal not allowed on chain"))?;
                if my_ceseal_timestamp >= req_ceseal_timestamp {
                    return Err(Status::internal("Same ceseal version or rollback ,No local handover provided"));
                }
            } else {
                info!("Both hashes are the same: {my_ceseal_hash:?}; ignore the timestamp check.");
            }
        } else {
            info!("Skip ceseal timestamp check in dev mode");
        }

        // Share the key with attestation
        let encrypted_id_key = id_key.as_encrypt_key(&[b"id_key_handover"], &challenge_handler.ecdh_pubkey);
        let encrypted_master_key =
            master_key.as_encrypt_key(&[b"master_key_handover"], &challenge_handler.ecdh_pubkey, block_number, 0);
        let genesis_block_hash = self.ceseal_client.genesis_hash().clone();
        let key_staffs = EncryptedKeyStaffs { genesis_block_hash, dev_mode, encrypted_id_key, encrypted_master_key };

        let key_staffs_hash = Arc::new(sp_core::hashing::blake2_256(&key_staffs.encode()));
        let attestation = if !dev_mode && in_sgx {
            let a = self
                .ceseal_client
                .make_attestation_report(key_staffs_hash)
                .await
                .map_err(as_status)?;
            Some(pb::Attestation { provider: a.provider, encoded_report: a.encoded_report, timestamp: a.timestamp })
        } else {
            info!("Omit RA report in workerkey response in dev mode");
            None
        };

        Ok(Response::new(pb::HandoverKeyStaffs::new(key_staffs, attestation)))
    }

    async fn shutdown(&self, _: Request<()>) -> RpcResult<()> {
        info!("Receive client shutdown request, Ceseal server will shutdown after 3 seconds");
        tokio::spawn(async move {
            tokio::time::sleep(std::time::Duration::from_secs(3)).await;
            info!("Ceseal server normal exit");
            // TODO: Shutdown the server gracefully
            std::process::exit(0);
        });
        Ok(Response::new(()))
    }
}

pub fn new_handover_client<Platform: pal::Platform>(config: Config, platform: Platform) -> HandoverClient<Platform> {
    HandoverClient { config, platform, handover_ecdh_key: None }
}

pub struct HandoverClient<Platform> {
    config: Config,
    platform: Platform,
    handover_ecdh_key: Option<EcdhKey>,
}

impl<Platform: pal::Platform> HandoverClient<Platform> {
    /// Key Handover Client: Process HandoverChallenge and return RA report
    pub async fn accept_challenge(&mut self, request: pb::HandoverChallenge) -> Result<pb::HandoverChallengeResponse> {
        // generate and save tmp key only for key handover encryption
        let handover_key = crate::new_sr25519_key();
        let handover_ecdh_key = handover_key.derive_ecdh_key().expect("should never fail with valid key; qed.");
        let ecdh_pubkey = ces_types::EcdhPublicKey::from_raw(handover_ecdh_key.public());
        self.handover_ecdh_key = Some(handover_ecdh_key);

        let challenge = request.decode_challenge()?;
        let dev_mode = challenge.dev_mode;
        // generate local attestation report to ensure the handover ceseals are on the same machine
        let sgx_local_report = if !dev_mode {
            let its_target_info = unsafe {
                sgx_api_lite::decode(&challenge.sgx_target_info)
                    .map_err(|_| anyhow!("Invalid client sgx target info"))?
            };
            // the report data does not matter since we only care about the origin
            let report = sgx_api_lite::report(its_target_info, &[0; 64])
                .map_err(|_| anyhow!("Failed to create client LA report"))?;
            sgx_api_lite::encode(&report).to_vec()
        } else {
            info!("Omit client LA report for dev mode challenge");
            vec![]
        };

        let challenge_handler = ChallengeHandlerInfo { challenge, sgx_local_report, ecdh_pubkey };
        let handler_hash = sp_core::hashing::blake2_256(&challenge_handler.encode());
        let attestation = if !dev_mode {
            let a = create_attestation_report_on(
                &self.platform,
                self.config.attestation_provider.clone(),
                &handler_hash,
                self.config.ra_timeout,
                self.config.ra_max_retries,
            )?;
            Some(pb::Attestation { provider: a.provider, encoded_report: a.encoded_report, timestamp: a.timestamp })
        } else {
            info!("Omit client RA report for dev mode challenge");
            None
        };

        Ok(pb::HandoverChallengeResponse::new(challenge_handler, attestation))
    }

    /// Key Handover Client: Receive encrypted worker key
    pub fn receive(&mut self, request: pb::HandoverKeyStaffs) -> Result<()> {
        let encrypted_key_staffs = request.decode_key_staffs()?;

        let dev_mode = encrypted_key_staffs.dev_mode;
        // verify RA report
        if !dev_mode {
            let key_staffs_hash = sp_core::hashing::blake2_256(&encrypted_key_staffs.encode());
            let raw_attestation = request.attestation.ok_or_else(|| anyhow!("Server attestation not found"))?;
            let attn_to_validate = Option::<AttestationReport>::decode(&mut &raw_attestation.encoded_report[..])
                .map_err(|_| anyhow!("Decode server attestation failed"))?;
            validate_attestation_report(attn_to_validate, &key_staffs_hash, unix_now(), false, vec![], false)
                .map_err(|_| anyhow!("Invalid server RA report"))?;
        } else {
            info!("Skip server RA report check for dev mode key");
        }

        let my_ecdh_key = self
            .handover_ecdh_key
            .as_ref()
            .ok_or_else(|| anyhow!("Handover ecdhkey not initialized"))?;
        let id_key = {
            let encrypted_key = encrypted_key_staffs.encrypted_id_key;
            let secret = key_share::decrypt_secret_from(
                my_ecdh_key,
                &encrypted_key.ecdh_pubkey.0,
                &encrypted_key.encrypted_key,
                &encrypted_key.iv,
            )
            .map_err(|e| anyhow!("handover_client failed to decrypt id key secret: {:?}", e))?;

            let key_pair = sr25519::Pair::restore_from_secret_key(&match secret {
                SecretKey::Sr25519(key) => key,
                _ => panic!("Expected sr25519 key, but got rsa key."),
            });
            IdentityKey { key_pair, trusted_sk: false, dev_mode }
        };
        use crate::identity_key::persistence::save_identity;
        // only seal if the key is successfully updated
        save_identity(&id_key, &self.platform, &PathBuf::from_str(&self.config.sealing_path)?)
            .map_err(|e| anyhow!("Failed to save identity key: {:?}", e))?;

        let master_key = {
            let encrypted_key = encrypted_key_staffs.encrypted_master_key;
            let secret = key_share::decrypt_secret_from(
                my_ecdh_key,
                &encrypted_key.ecdh_pubkey.0,
                &encrypted_key.encrypted_key,
                &encrypted_key.iv,
            )
            .map_err(|e| anyhow!("handover_client failed to decrypt master key secret: {:?}", e))?;
            let rsa_der = match secret {
                SecretKey::Rsa(key) => key,
                _ => panic!("Expected rsa key, but got sr25519 key."),
            };
            CesealMasterKey::from_rsa_der(&rsa_der)?
        };
        master_key.seal(&self.config.sealing_path, &id_key.key_pair, &self.platform);

        // clear cached RA report and handover ecdh key to prevent replay
        self.handover_ecdh_key = None;
        Ok(())
    }
}
